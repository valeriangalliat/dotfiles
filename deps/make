#!/usr/bin/env python3

import os
import shutil
import subprocess
import sys
import yaml

from functools import lru_cache


class Dep:
    def install(self):
        pass

    def update(self):
        pass


class Url(Dep):
    def __init__(self, url):
        self.url = url


class Git(Url):
    def install(self):
        return [['git', 'clone', self.url, '.']]

    def update(self):
        return [
            ['git', 'remote', 'set-url', 'origin', self.url],
            ['git', 'reset', '--hard'],
            ['git', 'clean', '-df'],
            ['git', 'pull'],
        ]


class GitHub(Git):
    def __init__(self, path):
        super().__init__('https://github.com/{0}.git'.format(path))


class Wget(Url):
    def __init__(self, url, name=None):
        super().__init__(url)
        self.name = name

    def install(self):
        # `nv` to have less verbosity, `-N` to take only newer and overwrite
        args = ['wget', '-nv', '-N']

        if self.name is not None:
            args.extend(('-O', self.name))

        args.append(self.url)

        return [args]

    def update(self):
        return self.install()


class Deploy:
    def __init__(self, selection, deps):
        self.selection = selection
        self.deps = deps


class Deps(dict, Dep):
    @classmethod
    def from_yaml(cls, stream):
        y = yaml.load(stream)
        d = cls()

        for cat, sub in y.items():
            d[cat] = {}

            for dir, opts in sub.items():
                type = opts['type']
                del opts['type']

                d[cat][dir] = getattr(sys.modules[__name__], type)(**opts)

        return d

    @classmethod
    def from_yaml_file(cls, file):
        with open(file, 'r') as f:
            return cls.from_yaml(f)

    def __iter__(self):
        for cat, sub in self.items():
            for dir, dep in sub.items():
                yield cat, dir, dep

    def sub(self, selection):
        d = __class__()

        for item in selection:
            if '.' in item:
                # Directory
                cat, dir = item.split('.', 1)

                if not cat in d:
                    d[cat] = {}

                d[cat][dir] = self[cat][dir]
            else:
                # Category
                cat = item
                d[cat] = self[cat]

        return d

    def install(self):
        for cat, dir, dep in self:
            dir = '/'.join([cat, dir])

            if not os.path.exists(dir):
                yield dir, dep.install()

    def update(self):
        for cat, dir, dep in self:
            dir = '/'.join([cat, dir])

            if os.path.exists(dir):
                yield dir, dep.update()


def rmtree(path, *args, **kwargs):
    '''Wrapper for `shutil.rmtree`, printing a `rm -rf` command.'''

    print('rm -rf {0}'.format(path))
    shutil.rmtree(path, *args, **kwargs)


def clean(deps):
    '''Walk the directory structure and remove any unknown directory.'''

    for path in os.listdir('.'):
        if not os.path.isdir(path):
            continue

        if not path in deps():
            rmtree(path)
            continue

        for subpath in os.listdir(path):
            if not subpath in deps()[path]:
                rmtree(os.path.join(path, subpath))


def task(deps, command, selection):
    '''Execute a task from `Dep` class on given selection.'''

    # Will throw if the command is not a `Dep` method
    getattr(Dep, command)

    if len(selection) == 0:
        tasks = getattr(deps(), command)()
    else:
        tasks = getattr(deps().sub(selection), command)()

    for dir, commands in tasks:
        cwd = os.getcwd()

        if not os.path.isdir(dir):
            os.makedirs(dir)

        os.chdir(dir)

        print(dir)

        for command in commands:
            print(' '.join(command))

            subprocess.call(command, stdin=sys.stdin, stdout=sys.stdout,
                            stderr=sys.stderr)

        print()

        os.chdir(cwd)


@lru_cache()
def deps():
    '''Lazy load and cache the dependencies data.'''
    return Deps.from_yaml_file('deps.yaml')


def main():
    assert(len(sys.argv) >= 2)

    # Always execute in program directory
    os.chdir(os.path.dirname(sys.argv[0]))

    command = sys.argv[1]

    if command == 'all':
        clean(deps)
        task(deps, 'install', sys.argv[2:])
        task(deps, 'update', sys.argv[2:])
    elif command == 'clean':
        clean(deps)
    else:
        task(deps, command, sys.argv[2:])


if __name__ == '__main__':
    main()
