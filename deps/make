#!/usr/bin/env python3

import json
import os
import shutil
import subprocess
import sys
import yaml

from functools import lru_cache


DEPS_FILE = 'deps.yaml'
DEPS_CACHE_FILE = 'deps.json'
CACHE_FILE = 'cache.json'


class Dep:
    def install(self):
        pass

    def update(self):
        pass


class Url(Dep):
    def __init__(self, url):
        self.url = url


class Git(Url):
    def install(self):
        return [['git', 'clone', self.url, '.']]

    def update(self):
        return [
            ['git', 'reset', '--hard'],
            ['git', 'clean', '-df'],
            ['git', 'pull'],
        ]


class GitHub(Git):
    def __init__(self, path):
        super().__init__('https://github.com/{0}.git'.format(path))


class Wget(Url):
    def __init__(self, url, name=None):
        super().__init__(url)
        self.name = name

    def install(self):
        # `nv` to have less verbosity, `-N` to take only newer and overwrite
        args = ['wget', '-nv', '-N']

        if self.name is not None:
            args.extend(('-O', self.name))

        args.append(self.url)

        return [args]

    def update(self):
        return self.install()


class Deploy:
    def __init__(self, selection, deps):
        self.selection = selection
        self.deps = deps


class Deps(dict, Dep):
    @classmethod
    def from_obj(cls, obj):
        d = cls()

        for cat, sub in obj.items():
            d[cat] = {}

            for dir, opts in sub.items():
                type = opts['type']
                del opts['type']

                d[cat][dir] = getattr(sys.modules[__name__], type)(**opts)

        return d

    def __iter__(self):
        for cat, sub in self.items():
            for dir, dep in sub.items():
                yield cat, dir, dep

    def sub(self, selection):
        d = __class__()

        for item in selection:
            if '.' in item:
                # Directory
                cat, dir = item.split('.', 1)

                if not cat in d:
                    d[cat] = {}

                d[cat][dir] = self[cat][dir]
            else:
                # Category
                cat = item
                d[cat] = self[cat]

        return d

    def install(self):
        for cat, dir, dep in self:
            dir = '/'.join([cat, dir])

            if not os.path.exists(dir):
                yield dir, dep.install()

    def update(self):
        for cat, dir, dep in self:
            dir = '/'.join([cat, dir])

            if os.path.exists(dir):
                yield dir, dep.update()


def rmtree(path, *args, **kwargs):
    '''Wrapper for `shutil.rmtree`, printing a `rm -rf` command.'''

    print('rm -rf {0}'.format(path))
    shutil.rmtree(path, *args, **kwargs)
    print()


def task(deps, command):
    '''Execute a task from `Dep` class on given selection.'''

    # Will throw if the command is not a `Dep` method
    getattr(Dep, command)

    tasks = getattr(deps, command)()

    for dir, commands in tasks:
        cwd = os.getcwd()

        if not os.path.isdir(dir):
            os.makedirs(dir)

        os.chdir(dir)

        print(dir)

        for command in commands:
            print(' '.join(command))

            subprocess.call(command, stdin=sys.stdin, stdout=sys.stdout,
                            stderr=sys.stderr)

        print()

        os.chdir(cwd)


@lru_cache()
def deps(selection=None):
    if selection is not None and len(selection) != 0:
        return deps().sub(selection)

    try:
        if os.path.getctime(DEPS_FILE) > os.path.getctime(DEPS_CACHE_FILE):
            # Raise dummy error to jump to exception handling
            raise FileNotFoundError()
        else:
            obj = json.load(open(DEPS_CACHE_FILE))
    except FileNotFoundError:
        obj = yaml.load(open(DEPS_FILE, 'r'))

        # Save new object to cache
        json.dump(obj, open(DEPS_CACHE_FILE, 'w'))

    return Deps.from_obj(obj)


@lru_cache()
def cache():
    try:
        return json.load(open(CACHE_FILE))
    except FileNotFoundError:
        return {}


def clean_removed(deps):
    '''Walk the directory structure and remove any unknown directory.'''

    for path in os.listdir('.'):
        if not os.path.isdir(path):
            continue

        if not path in deps:
            rmtree(path)
            continue

        for subpath in os.listdir(path):
            if not subpath in deps[path]:
                rmtree(os.path.join(path, subpath))


def clean_existing(deps, cache):
    '''Remove existing directories that don't match current dependencies.'''

    for cat, dir, dep in deps:
        key = '{0}/{1}'.format(cat, dir)

        if not key in cache:
            continue

        if (cache[key]['class'] != dep.__class__.__name__
            or cache[key]['dict'] != dep.__dict__):
            rmtree(os.path.join(cat, dir))


def before(deps, cache):
    clean_removed(deps)
    clean_existing(deps, cache)


def after(deps):
    '''Write cache file of installed dependencies.'''

    cache = {}

    for cat, dir, dep in deps:
        key = '{0}/{1}'.format(cat, dir)

        cache[key] = {
            'class': dep.__class__.__name__,
            'dict': dep.__dict__,
        }

    json.dump(cache, open(CACHE_FILE, 'w'))


def main():
    assert(len(sys.argv) >= 2)

    # Always execute in program directory
    os.chdir(os.path.dirname(sys.argv[0]))

    command = sys.argv[1]
    selection = sys.argv[2:]

    deps_ = deps(tuple(selection))
    cache_ = cache()

    before(deps_, cache_)

    if command == 'all':
        task(deps_, 'install')
        task(deps_, 'update')
    else:
        task(deps_, command)

    after(deps_)


if __name__ == '__main__':
    main()
